# Zircon on Raspberry Pi 4B Board
# created by gobftald (for not only black belt professionals)


## Serial Console

You may use a 3.3v FTDI USB to serial cable to access the miniUART serial console
https://www.raspberrypi.org/documentation/usage/gpio/

- Pin 6: Ground         -> GND of FTDI adapter
- Pin 8: GPIO 14 (TXD)  -> RXD of FTDI adapter
- Pin 10 GPIO 15 (RXD)  -> TXD of FTDI adapter


## Bootloader

Build "u-boot" bootloader for making the zircon image download to SD card easy

- if you don't have yet, install GNU Arm Embedded Toolchain (Linux)
> sudo apt-get install gcc-aarch64-linux-gnu gcc-arm-none-eabi

- download u-boot source from its official git
> git clone https://github.com/u-boot/u-boot.git
> cd u-boot

- make a ".config" file for u-boot building
> make rpi_arm64_defconfig
  
- default u-boot image made by the previous config works on 64 bit Raspbian 
  but won't work with fuchsia
  64 bit "u-boot" runs with MMU enabled which kills zircon's initialization
  here is a brute force dirty patch method for u-boot to disable its MMU function:

  insert the following line
    CONFIG_SYS_DCACHE_OFF=y  
  into ".config" file generated by the previous "make rpi_arm64_defconfig" command

  then edit/patch the following "u-boot" source files:
    in "arch/arm/cpu/armv8/cache_v8.c"
      comment out the "#error ..." command
      ...
      #ifndef CONFIG_SPL_BUILD
>     //#error Please describe your MMU layout in CONFIG_SYS_MEM_MAP and enable dcache.
      #endif
      ...

    in "arch/arm/lib/cache.c"
    comment out the following line
      ...
      /* reserve TLB table */
>     /*gd->arch.tlb_size = PGTABLE_SIZE;*/
      gd->relocaddr -= gd->arch.tlb_size;
      ...

- build bootloader image (u-boot.bin)
> CROSS_COMPILE=aarch64-linux-gnu- make

- copy "u-boot.bin" file  to the SD card


## Build ARM's Trusted Firmware for PSCI functions

PSCI functions are needed for spinnig up (switch on) the remaining (secondary) CPUs/Cores

- donwload TF-A source from its official git
> git clone "https://review.trustedfirmware.org/TF-A/trusted-firmware-a"
> cd trusted-firmware-a

- build TF-A firmware image (bl31.bin) for rpi4 plaform
> CROSS_COMPILE=aarch64-linux-gnu- make PLAT=rpi4

- copy "bl31.bin" file to the SD card


## copy Raspberry Pi default firmware and device tree to SD card

these files can be found and extracted from Raspbian factory SD card image
but we need only three files from them, so they can be dowloaded separately:

- get/donwload "start4.elf" and "fixup4.dat" firmware files and
  "bcm2711-rpi-4-b.dtb" device tree file from 
  https://github.com/raspberrypi/firmware/tree/master/boot

- then copy these three files to SD card


## config.txt on SD card

if all previous files were made and copied to SD card, we need to configure them
in the default config.txt file created on SD card

- here are the list of necessary files we get/made/copied
> bl31.bin
> u-boot.bin
> bcm2711-rpi-4-b.dtb
> start4.elf
> fixup4.dat
  all of them in the root folder of SD card

- create and edit a file named "config.txt", also in the root folder of SD card
> config.txt
    # boot into zedboot.zbi.shim
    arm_64bit=1
    enable_uart=1
    armstub=bl31.bin
    #kernel=zedboot.zbi.shim
    kernel=u-boot.bin

- if we finished development we can copy the final zircon image (zedboot.zbi.shim)
  to SD card then swap comment (#) of "kernel=..." lines into
  kernel=zedboot.zbi.shim
  #kernel=u-boot.bin" as well)
  from now zircon will boot automatically 
  since device tree (bcm2711-rpi-4-b.dtb) only needed for u-boot, it can be deleted


## load and run zircon by u-boot

- when Raspberry Pi 4 is powered, pervious configuration on SD card will load
  "bl31.bin" firmware then "u-boot.bin" bootloader as a kernel into the RAM

- then we get an "u-boot prompt" where we can use tftp command to load the necessary
  zedboot.zbi.shim image from the machine where we built it

- see u-boot's help command and environment variables to setup IP parameters of tftp
  in client side, check whether it installed and setup tftp server on developer machine
  client side, e.g.:
    printenv
    setev bootdelay 10
    setenv ipaddr 192.168.x.y
    setenv serverip 192.168.x.z
    setenv netmask 255.255.255.0
    saveenv
    printenv

- if tftp connection works properly load and run zircon into Raspberry Pi
> tftp zedboot.zbi.shim
> go 80000

- tftp loads zircon image to the default 0x80000 address
  this gives/skips enough space to bl31.bin which was loaded to/from 0x0000 address
  even if it build with debug information
  if you want to make more spaces to zircon check size of bl31.bin and load and run
  zircon to/from a lower address, e.g.:
> tftp 10000 zedboot.zbi.shim
> go 10000

- you don't care where u-boot located in RAM, since when it loaded it relocates itself 
  to the upper end of Memory,
  after "go" command, no further need for it, so zircon can allocate the whole RAM
  available until the start of Video RAM area
